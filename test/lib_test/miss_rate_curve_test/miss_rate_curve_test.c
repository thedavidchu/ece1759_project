#include <inttypes.h>
#include <stdbool.h>
#include <stdint.h>

#include <glib.h>
#include <stdio.h>

#include "histogram/histogram.h"
#include "logger/logger.h"
#include "miss_rate_curve/miss_rate_curve.h"

#include "math/doubles_are_equal.h"
#include "test/mytester.h"
#include "unused/mark_unused.h"

// NOTE Histogram oracle generated by getting the random values generated
//      above and running:
//      y = [x.count(i) for i in range(10)]; print(y); z = x.count(10);
//      print(z)
static uint64_t DENSE_HIST_VALS[] = {9, 9, 12, 9, 4, 8, 15, 9, 6, 8};
static struct Histogram DENSE_HIST = {
    .histogram = DENSE_HIST_VALS,
    .num_bins = 10,
    .bin_size = 1,
    .false_infinity = 11,
    .infinity = 3,
    .running_sum = 103,
};

static uint64_t SPARSE_HIST_VALS[] = {9, 9, 12, 9, 0, 8, 15, 9, 6, 8};
static struct Histogram SPARSE_HIST = {
    .histogram = SPARSE_HIST_VALS,
    .num_bins = 10,
    .bin_size = 1,
    .false_infinity = 11,
    .infinity = 3,
    .running_sum = 99,
};

static uint64_t VERY_SPARSE_HIST_VALS[] = {0, 9, 12, 9, 0, 8, 0, 0, 6, 8};
static struct Histogram VERY_SPARSE_HIST = {
    .histogram = VERY_SPARSE_HIST_VALS,
    .num_bins = 10,
    .bin_size = 1,
    .false_infinity = 0,
    .infinity = 3,
    .running_sum = 55,
};

static bool
exact_match(struct MissRateCurve *lhs, struct MissRateCurve *rhs)
{
    assert(lhs != NULL && rhs != NULL && lhs->miss_rate != NULL &&
           rhs->miss_rate != NULL);
    if (lhs->num_bins != rhs->num_bins) {
        return false;
    }
    for (uint64_t i = 0; i < lhs->num_bins; ++i) {
        if (!doubles_are_equal(lhs->miss_rate[i], rhs->miss_rate[i])) {
            LOGGER_ERROR("Mismatch in iteration %" PRIu64 ": %lf != %lf\n",
                         i,
                         lhs->miss_rate[i],
                         rhs->miss_rate[i]);
            return false;
        }
    }
    return true;
}

static bool
test_miss_rate_curve_from_histogram(struct Histogram *hist)
{
    g_assert_true(Histogram__validate(hist));

    struct MissRateCurve mrc = {0};
    struct MissRateCurve mrc_from_file = {0};
    g_assert_true(MissRateCurve__init_from_histogram(&mrc, hist));
    g_assert_true(MissRateCurve__validate(&mrc));

    // Test the serialization/deserialization
    g_assert_true(MissRateCurve__write_binary_to_file(&mrc, "./mrc.bin"));
    g_assert_true(MissRateCurve__init_from_file(&mrc_from_file,
                                                "./mrc.bin",
                                                mrc.num_bins,
                                                1));
    g_assert_true(MissRateCurve__validate(&mrc_from_file));
    g_assert_true(exact_match(&mrc, &mrc_from_file));
    MissRateCurve__destroy(&mrc_from_file);
    g_assert_cmpint(remove("./mrc.bin"), ==, 0);

    // Test the serialization/deserialization with sparsity
    g_assert_true(
        MissRateCurve__write_sparse_binary_to_file(&mrc, "./mrc.bin"));
    g_assert_true(MissRateCurve__init_from_sparse_file(&mrc_from_file,
                                                       "./mrc.bin",
                                                       mrc.num_bins,
                                                       1));
    g_assert_true(MissRateCurve__validate(&mrc_from_file));
    g_assert_true(exact_match(&mrc, &mrc_from_file));
    g_assert_cmpint(remove("./mrc.bin"), ==, 0);

    // Test the MSE function
    g_assert_true(MissRateCurve__mean_squared_error(&mrc, &mrc_from_file) ==
                  0.0);
    MissRateCurve__destroy(&mrc);
    MissRateCurve__destroy(&mrc_from_file);
    return true;
}

int
main(int argc, char **argv)
{
    UNUSED(argc);
    UNUSED(argv);
    ASSERT_FUNCTION_RETURNS_TRUE(
        test_miss_rate_curve_from_histogram(&DENSE_HIST));
    ASSERT_FUNCTION_RETURNS_TRUE(
        test_miss_rate_curve_from_histogram(&SPARSE_HIST));
    ASSERT_FUNCTION_RETURNS_TRUE(
        test_miss_rate_curve_from_histogram(&VERY_SPARSE_HIST));
    return 0;
}
